<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>宇宙ミニゲーム・コレクション</title>
<style>
  :root { --bg:#0b1020; --fg:#e8f1ff; --muted:#a9b6d3; --acc:#88aaff; --good:#35d07f; --bad:#ff6b6b; --btn:#1c2b4b; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;}
  -  #ui{position:fixed;inset:0;pointer-events:none;}
  +  #ui{position:fixed;inset:0;pointer-events:none; z-index:10;}
  .topbar{position:absolute;left:8px;right:8px;top:8px;display:flex;gap:8px;align-items:center;pointer-events:auto;}
  .b{background:#16213a;color:var(--fg);border:1px solid #2c3b66;border-radius:10px;padding:10px 12px;font-size:14px}
  .b:active{transform:translateY(1px)}
  .primary{background:var(--btn)}
  .ghost{background:transparent;border-color:#3b4d80}
  .good{background:var(--good);color:#062410;border:none}
  .bad{background:var(--bad);color:#2b0000;border:none}
  .panel{position:absolute;inset:auto 8px 8px 8px;background:rgba(7,12,28,.85);border:1px solid #2c3b66;border-radius:12px;padding:12px;pointer-events:auto}
  #menu{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;pointer-events:auto}
  .card{width:min(560px,92vw);background:#101a36;border:1px solid #2c3b66;border-radius:16px;padding:14px}
  h1{margin:0 0 6px;font-size:22px}
  p{margin:6px 0;color:var(--muted);line-height:1.5}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .foot{opacity:.8;font-size:12px;margin-top:8px}
  .stick{position:absolute;bottom:18px;left:18px;width:120px;height:120px;border-radius:50%;background:#0c1530aa;border:1px solid #2c3b66;pointer-events:auto;touch-action:none}
  .stick .knob{position:absolute;left:50%;top:50%;width:56px;height:56px;margin:-28px 0 0 -28px;border-radius:50%;background:#20325faa;border:1px solid #3a4f86}
  .rightpad{position:absolute;right:18px;bottom:18px;display:flex;flex-direction:column;gap:10px;pointer-events:auto}
  .big{font-size:16px;padding:14px 18px;border-radius:12px}
  a{color:var(--acc);text-decoration:none}
  details{margin:8px 0}
</style>
</head>
<body>
<!-- p5.js CDN（会場がオフラインならローカルに差し替え） -->
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

<div id="ui">
  <!-- トップバー -->
  <div class="topbar">
    <button class="b primary" id="btnMenu">メニュー</button>
    <button class="b ghost" id="btnAbout">解説</button>
    <span id="status" style="margin-left:auto;color:#c7d4ff"></span>
  </div>

  <!-- メニュー -->
  <div id="menu" hidden>
    <div class="card">
      <h1>宇宙ミニゲーム・コレクション</h1>
      <p>スマホでもOK。文化祭用に設計。遊んだあとに「解説」で科学的な背景を読めます。</p>
      <div class="grid" style="margin-top:8px">
        <button class="b big" id="goBH">① ブラックホール脱出</button>
        <button class="b big" id="goCON">② 星座つなぎ</button>
        <button class="b big" id="goDOP">③ ドップラー当て</button>
        <button class="b big" id="goLEN">④ 重力レンズ迷路</button>
      </div>
      <p class="foot">操作：左下スティック or 端末の傾き（iOSは下の許可が必要）</p>
      <button class="b" id="askMotion">加速度センサーを許可（iOS）</button>
    </div>
  </div>

  <!-- 解説パネル -->
  <div class="panel" id="about" hidden>
    <h2 style="margin:0 0 8px">解説（ざっくり）</h2>
    <details open>
      <summary>① ブラックホール脱出</summary>
      <p>中心質量による引力を簡略化（∝1/r²）して宇宙船の運動をシミュレーション。事象の地平線半径を閾値として「脱出不可」を体験化。</p>
    </details>
    <details>
      <summary>② 星座つなぎ</summary>
      <p>星座は地球からの見かけの並び。実距離はバラバラ。線でつなぐと形が浮かぶが、三次元では散らばっている。</p>
    </details>
    <details>
      <summary>③ ドップラー当て</summary>
      <p>光の波長は運動で伸び縮み。遠ざかる＝赤方偏移、近づく＝青方偏移。宇宙の大域膨張では遠方銀河ほど赤く（ハッブル則）。</p>
    </details>
    <details>
      <summary>④ 重力レンズ迷路</summary>
      <p>質量は時空を曲げ、光路は曲がる。銀河団をレンズにして遠方銀河が増光・多重像に。ここでは点質量の近似で光線を微分方程式的に曲げる。</p>
    </details>
    <p class="foot">詳しい資料や参考URLはあなたの研究ページに差し替えてOK（このパネルはHTML編集で増やせます）。</p>
  </div>

  <!-- 画面スティック／右操作 -->
  <div class="stick" id="stick"><div class="knob"></div></div>
  <div class="rightpad" id="rightpad" hidden>
    <button class="b good big" id="btnBlue">近づく（青方）</button>
    <button class="b bad big" id="btnRed">遠ざかる（赤方）</button>
  </div>
</div>

<script>
/* =========================
   共通：状態・入力
========================= */
let W=window.innerWidth, H=window.innerHeight;
let current = 'menu'; // 'menu','about','bh','con','dop','len'
let statusEl = document.getElementById('status');
const menuEl = document.getElementById('menu');
const aboutEl = document.getElementById('about');
const rightpadEl = document.getElementById('rightpad');

document.getElementById('btnMenu').onclick = ()=>setState('menu');
document.getElementById('btnAbout').onclick = ()=>setState('about');
document.getElementById('goBH').onclick = ()=>startBH();
document.getElementById('goCON').onclick = ()=>startCON();
document.getElementById('goDOP').onclick = ()=>startDOP();
document.getElementById('goLEN').onclick = ()=>startLEN();

document.getElementById('askMotion').onclick = async ()=>{
  try{
    // iOS 13+ の許可リクエスト
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      const r = await DeviceMotionEvent.requestPermission();
      alert(r==='granted'?'有効化しました。傾きで操作できます。':'許可されませんでした。スティックで操作してください。');
    } else {
      alert('この端末は明示許可不要、または未対応です。');
    }
  }catch(e){ alert('許可リクエストでエラー: '+e); }
};

function setState(s){
  current = s;
  menuEl.hidden = (s!=='menu');
  aboutEl.hidden = (s!=='about');
  rightpadEl.hidden = (s!=='dop'); // ドップラーだけ選択ボタンを出す
}

let joy = {active:false, base:null, knob:null, dx:0, dy:0};
(function initStick(){
  const el = document.getElementById('stick');
  joy.base = el;
  joy.knob = el.querySelector('.knob');
  const start = (e)=>{
    joy.active = true;
    move(e);
    e.preventDefault();
  };
  const move = (e)=>{
    if(!joy.active) return;
    const r = joy.base.getBoundingClientRect();
    const cx = r.left + r.width/2, cy = r.top + r.height/2;
    const pt = getPoint(e);
    let dx = pt.x - cx, dy = pt.y - cy;
    const max = r.width*0.45;
    const mag = Math.hypot(dx,dy);
    if(mag>max){ dx*=max/mag; dy*=max/mag; }
    joy.knob.style.transform = `translate(${dx}px,${dy}px)`;
    joy.dx = dx/max; joy.dy = dy/max;
  };
  const end = ()=>{
    joy.active=false; joy.dx=0; joy.dy=0;
    joy.knob.style.transform = 'translate(0,0)';
  };
  el.addEventListener('pointerdown', start);
  window.addEventListener('pointermove', move);
  window.addEventListener('pointerup', end);
  window.addEventListener('pointercancel', end);
})();
function getPoint(e){
  if(e.touches && e.touches[0]) return {x:e.touches[0].clientX,y:e.touches[0].clientY};
  return {x:e.clientX,y:e.clientY};
}

/* =========================
   p5: ベース
========================= */
let accel = {ax:0, ay:0}; // 傾き加速度（簡易）
window.addEventListener('deviceorientation', (ev)=>{
  // 画面の傾きを簡易的に 2D 入力に変換（縦持ち前提）
  const gx = Math.sin((ev.gamma||0)*Math.PI/180);
  const gy = Math.sin((ev.beta||0)*Math.PI/180);
  accel.ax = gx; accel.ay = gy;
});

let sketch = (p)=>{
  p.setup = ()=>{
    p.createCanvas(W,H);
    setState('menu');
    setupBH(p); setupCON(p); setupDOP(p); setupLEN(p);
  };
  p.windowResized = ()=>{ W=window.innerWidth; H=window.innerHeight; p.resizeCanvas(W,H); };
  p.draw = ()=>{
    p.background(10,16,36);
    if(current==='menu'){
      drawStarsBG(p);
    }else if(current==='about'){
      drawStarsBG(p);
    }else if(current==='bh'){ drawBH(p); }
    else if(current==='con'){ drawCON(p); }
    else if(current==='dop'){ drawDOP(p); }
    else if(current==='len'){ drawLEN(p); }
  };
};
new p5(sketch);

/* =========================
   共有：星背景
========================= */
let bgStars = [];
function drawStarsBG(p){
  if(bgStars.length===0){
    for(let i=0;i<180;i++){
      bgStars.push({x:Math.random()*W,y:Math.random()*H,s:Math.random()*2+0.5,t:Math.random()*TAU});
    }
  }
  p.noStroke();
  for(const s of bgStars){
    s.t += 0.02;
    const tw = (Math.sin(s.t)+1)*0.5*180+50;
    p.fill(200,220,255,tw);
    p.circle(s.x,s.y,s.s);
  }
}
const TAU = Math.PI*2;

/* =========================
   ① ブラックホール脱出
========================= */
let bh;
function setupBH(p){
  const reset=()=>({
    ship:{x:W*0.75,y:H*0.5,vx:0,vy:-2, r:10},
    t:0, alive:true, score:0,
    R: Math.min(W,H)*0.1, // 事象の地平線擬似
    G: 1400 // 引力強さ
  });
  bh = reset();
  bh.reset = ()=>Object.assign(bh, reset());
}
function startBH(){ setState('bh'); bh.reset(); }
function drawBH(p){
  // 中央ブラックホール描画
  p.push();
  p.translate(W/2,H/2);
  const EH = bh.R;
  for(let i=0;i<40;i++){
    const r = EH + i*2;
    p.noFill(); p.stroke(40,60,120,120-i*3); p.circle(0,0,r*2);
  }
  p.noStroke(); p.fill(20); p.circle(0,0,EH*2); // 事象の地平線
  p.pop();

  // 宇宙船の力学
  const s = bh.ship;
  // 入力（傾き + スティック）を合成
  const ux = accel.ax*0.8 + joy.dx*1.2;
  const uy = accel.ay*0.8 + joy.dy*1.2;

  // 推力
  s.vx += ux*0.3; s.vy += uy*0.3;

  // 引力（1/r^2にソフト化）
  const dx = W/2 - s.x, dy = H/2 - s.y;
  const r = Math.hypot(dx,dy);
  const soft = 60;
  const a = bh.G / ((r*r)+soft*soft);
  s.vx += a*dx; s.vy += a*dy;

  // 速度制限
  const vmax = 8;
  const v = Math.hypot(s.vx,s.vy);
  if(v>vmax){ s.vx*=vmax/v; s.vy*=vmax/v; }

  // 位置更新
  s.x += s.vx; s.y += s.vy;

  // 壁バウンド
  if(s.x<0||s.x>W){ s.vx*=-0.7; s.x=Math.max(0,Math.min(W,s.x)); }
  if(s.y<0||s.y>H){ s.vy*=-0.7; s.y=Math.max(0,Math.min(H,s.y)); }

  // 判定
  if(r<bh.R){ bh.alive=false; }
  if(bh.alive) bh.t += 1;

  // スコア＝生存時間（秒）
  bh.score = (bh.t/60).toFixed(1);

  // 宇宙船描画
  p.push();
  p.translate(s.x,s.y);
  p.rotate(Math.atan2(s.vy,s.vx));
  p.fill(220); p.triangle(-12,-6,-12,6,12,0);
  p.fill(255,160); p.triangle(-12,-4,-12,4,-20,0); // 排気
  p.pop();

  statusEl.textContent = bh.alive?`生存 ${bh.score}s`:`吸い込まれた！ 生存 ${bh.score}s`;

  if(!bh.alive){
    p.fill(255,230,240,210); p.noStroke();
    p.textAlign(p.CENTER,p.CENTER);
    p.textSize(22);
    p.text('ゲームオーバー\nメニューでやり直し', W/2, H*0.2);
  }
}

/* =========================
   ② 星座つなぎ（オリオン簡略）
========================= */
let con;
function setupCON(p){
  // 画面に合わせて星座座標をスケーリング
  function make(){
    const cx=W*0.5, cy=H*0.5, s=Math.min(W,H)*0.28;
    // 簡略オリオン：ベテルギウス, ベラトリクス, 三ツ星, リゲル, サイフ など
    const pts = [
      {name:'Betelgeuse', x:-0.2, y:-0.4},
      {name:'Bellatrix',  x: 0.2, y:-0.35},
      {name:'Mintaka',    x:-0.25,y:-0.05},
      {name:'Alnilam',    x: 0.00,y: 0.00},
      {name:'Alnitak',    x: 0.25,y: 0.05},
      {name:'Rigel',      x: 0.25,y: 0.40},
      {name:'Saiph',      x:-0.15,y: 0.38}
    ].map(p=>({name:p.name, x:cx+p.x*s, y:cy+p.y*s, r:10}));
    // 正解の結線順（インデックス）
    const order = [0,2,3,4,5,6,3,1,0]; // ざっくり輪郭＋三ツ星
    return {pts, order, cur:0, lines:[], done:false};
  }
  con = make();
  con.reset = ()=>Object.assign(con, make());
}
function startCON(){ setState('con'); con.reset(); }
function drawCON(p){
  drawStarsBG(p);
  // 星を描く
  p.noStroke();
  for(const s of con.pts){
    p.fill(220);
    p.circle(s.x,s.y,s.r);
  }
  // 線
  p.stroke(150,190,255); p.strokeWeight(2);
  for(const L of con.lines){
    p.line(L.x1,L.y1,L.x2,L.y2);
  }
  // 次の目標をやさしく強調
  const idx = con.order[con.cur];
  const target = con.pts[idx];
  p.noFill(); p.stroke(255,220,120,180);
  p.circle(target.x,target.y,24);

  // タップ処理（p5 の mouseIsPressed を使用）
  if(p.mouseIsPressed){
    // 一度のタップで複数進行しないようにフレームデバウンス
    if(!con._down){
      con._down=true;
      const hit = hitStar(p.mouseX,p.mouseY, con.pts);
      if(hit===idx){
        // 正解：線を追加
        if(con.cur>0){
          const prev = con.pts[ con.order[con.cur-1] ];
          con.lines.push({x1:prev.x,y1:prev.y,x2:target.x,y2:target.y});
        }
        con.cur++;
        if(con.cur>=con.order.length){ con.done=true; }
      }
    }
  } else con._down=false;

  // 完成エフェクト
  if(con.done){
    p.noStroke();
    for(let i=0;i<40;i++){
      p.fill(255,240,120,120-i*3);
      p.circle(W/2,H/2, i*8);
    }
    p.fill(255); p.textAlign(p.CENTER); p.textSize(20);
    p.text('星座完成！', W/2, H*0.15);
  }
  statusEl.textContent = con.done?'完成！':'点を順にタップして線で結ぼう';
}
function hitStar(x,y,pts){
  for(let i=0;i<pts.length;i++){
    const s=pts[i]; if((x-s.x)**2+(y-s.y)**2<= (s.r*1.1)**2) return i;
  }
  return -1;
}

/* =========================
   ③ ドップラー当て
========================= */
let dop;
function setupDOP(p){
  const reset=()=>({
    t:0, score:0, life:3,
    // 現在のターン
    cur:{x:W*0.1,y:H*0.5,v:2, vr: 300, // 見かけの接近速度 km/s（符号付）
         color:[200,200,255], answer:null}
  });
  dop = reset();
  dop.reset = ()=>Object.assign(dop, reset());
  document.getElementById('btnBlue').onclick = ()=>judgeDOP(-1);
  document.getElementById('btnRed').onclick  = ()=>judgeDOP(+1);
}
function startDOP(){ setState('dop'); dop.reset(); spawnDOP(); }
function spawnDOP(){
  const vr = (Math.random()<0.5?-1:1) * (50+Math.random()*600); // ±50–650 km/s
  // vr>0 なら遠ざかる→赤、vr<0 なら近づく→青
  const hue = vr>0 ? [255,120,120] : [120,160,255];
  dop.cur = {x:W*0.08,y:Math.random()*H*0.6+H*0.2,v: 2.3+Math.random()*1.7, vr, color:hue, answer: (vr<0?-1:+1)};
}
function drawDOP(p){
  rightpadEl.hidden=false;
  // 背景のスペクトル風
  for(let i=0;i<W;i+=6){
    const r = 80+80*Math.sin((i+performance.now()*0.0008));
    p.stroke(r, r*0.9, 180,60); p.line(i,0,i,H);
  }
  // 星アイコン
  const c = dop.cur;
  c.x += c.v;
  p.noStroke(); p.fill(c.color[0],c.color[1],c.color[2]);
  p.circle(c.x, c.y, 28);
  // 速度テープ
  p.fill(230); p.textSize(14); p.textAlign(p.LEFT);
  p.text('判定：近づく=青方 / 遠ざかる=赤方', 10, 24);

  // 画面外に出たらライフ減
  if(c.x>W+20){
    dop.life--; spawnDOP();
  }

  // ステータス
  statusEl.textContent = `スコア ${dop.score} / ライフ ${dop.life}`;
  if(dop.life<=0){
    p.fill(255); p.textAlign(p.CENTER); p.textSize(22);
    p.text('ゲーム終了！ メニューでリトライ', W/2, H*0.5);
  }
}
function judgeDOP(guess){ // guess: -1=近づく, +1=遠ざかる
  if(dop.life<=0) return;
  const correct = (guess===dop.cur.answer);
  if(correct){ dop.score++; flash(60, 'good'); }
  else { dop.life--; flash(60,'bad'); }
  spawnDOP();
}
let flashTicks=0, flashMode='good';
function flash(n,mode){ flashTicks=n; flashMode=mode; }
(function flashLayer(){
  // 画面フラッシュ用のオーバーレイ（p5外）
  const overlay=document.createElement('div');
  overlay.style.position='fixed'; overlay.style.inset='0';
  overlay.style.pointerEvents='none'; overlay.style.opacity='0';
  overlay.style.transition='opacity 0.08s';
  document.body.appendChild(overlay);
  function step(){
    if(flashTicks>0){
      overlay.style.background= flashMode==='good' ? '#35d07f55' : '#ff6b6b55';
      overlay.style.opacity='1'; flashTicks--;
    } else overlay.style.opacity='0';
    requestAnimationFrame(step);
  }
  step();
})();

/* =========================
   ④ 重力レンズ迷路
========================= */
let lenz;
function setupLEN(p){
  const reset=()=>({
    src:{x:W*0.12,y:H*0.5}, goal:{x:W*0.88,y:H*0.5, r:18},
    mass:{x:W*0.5,y:H*0.5,M: 24000, r:26, dragging:false},
    ray:[], // 光線の軌跡（点列）
    solved:false, fail:false, ticks:0
  });
  lenz = reset();
  lenz.reset = ()=>Object.assign(lenz, reset());

  // ドラッグ
  window.addEventListener('pointerdown',(e)=>{
    if(current!=='len') return;
    const pt=getPoint(e);
    if(dist2(pt.x,pt.y,lenz.mass.x,lenz.mass.y) < (lenz.mass.r+10)**2){
      lenz.mass.dragging=true;
    }
  });
  window.addEventListener('pointermove',(e)=>{
    if(current!=='len' || !lenz.mass.dragging) return;
    const pt=getPoint(e); lenz.mass.x=pt.x; lenz.mass.y=pt.y;
  });
  window.addEventListener('pointerup',()=>{ if(current==='len') lenz.mass.dragging=false; });
}
function startLEN(){ setState('len'); lenz.reset(); }
function dist2(x1,y1,x2,y2){ return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2); }

function drawLEN(p){
  drawStarsBG(p);

  // 目標と質量
  p.noStroke();
  p.fill(120,220,255,180); p.circle(lenz.goal.x,lenz.goal.y,lenz.goal.r*2);
  p.fill(255,230,120,200); p.circle(lenz.src.x,lenz.src.y,14);
  p.fill(120,160,255,180); p.circle(lenz.mass.x,lenz.mass.y,lenz.mass.r*2);

  // 光線を放射：オイラー積分で少しずつ進めながら近傍で曲げる
  const pts = [];
  let x=lenz.src.x, y=lenz.src.y;
  // 初期は右向き
  let vx=3.0, vy=0.0;
  for(let i=0;i<1300;i++){
    // レンズ質量からの擬似加速（1/r^2, 係数小さめ）
    const dx=lenz.mass.x-x, dy=lenz.mass.y-y;
    const rr = Math.max(40, Math.hypot(dx,dy));
    const a = lenz.mass.M/(rr*rr*2600); // 調整済み係数（見た目優先）
    vx += a*dx; vy += a*dy;
    // 正規化＆速度一定気味に
    const v=Math.hypot(vx,vy); vx/=v; vy/=v; vx*=3.0; vy*=3.0;
    x+=vx; y+=vy; pts.push([x,y]);
    // 成功判定
    if(dist2(x,y,lenz.goal.x,lenz.goal.y) < (lenz.goal.r)**2){ lenz.solved=true; break; }
    // 画面外
    if(x<0||x>W||y<0||y>H) break;
  }
  // 描画
  p.noFill(); p.stroke(255,240,180,200); p.strokeWeight(2);
  p.beginShape();
  for(const q of pts) p.vertex(q[0],q[1]);
  p.endShape();
  // ガイド
  p.noStroke(); p.fill(255); p.textSize(16);
  p.textAlign(p.LEFT);
  p.text('銀河（青丸）をドラッグして光をゴールへ曲げよう', 10, 22);

  statusEl.textContent = lenz.solved?'クリア！':'ドラッグで配置を調整';

  if(lenz.solved){
    p.fill(255); p.textAlign(p.CENTER); p.textSize(22);
    p.text('クリア！ 解説で仕組みを読もう', W/2, H*0.15);
  }
}

setState('menu');

</script>
</body>
</html>

