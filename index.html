<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>宇宙ミニゲーム・コレクション</title>
<style>
  :root { --bg:#0b1020; --fg:#e8f1ff; --muted:#a9b6d3; --acc:#88aaff; --good:#35d07f; --bad:#ff6b6b; --btn:#1c2b4b; }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif;touch-action:manipulation}
  /* UIは前面、キャンバスは背面に固定 */
  #ui{position:fixed;inset:0;pointer-events:auto;z-index:10;}
  .hidden{display:none !important;}
  canvas{position:fixed;inset:0;z-index:-1 !important;pointer-events:none !important;}

  /* 使うUIスタイル（必要最小限） */
  .topbar{position:absolute;left:8px;right:8px;top:8px;display:flex;gap:8px;align-items:center}
  .b{background:#16213a;color:var(--fg);border:1px solid #2c3b66;border-radius:10px;padding:10px 12px;font-size:14px}
  .b:active{transform:translateY(1px)}
  .primary{background:var(--btn)}
  .good{background:var(--good);color:#062410;border:none}
  .bad{background:var(--bad);color:#2b0000;border:none}
  .card{width:min(560px,92vw);background:#101a36;border:1px solid #2c3b66;border-radius:16px;padding:14px}
  h1{margin:0 0 6px;font-size:22px}
  p{margin:6px 0;color:var(--muted);line-height:1.5}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .foot{opacity:.8;font-size:12px;margin-top:8px}
  .stick{position:absolute;bottom:18px;left:18px;width:120px;height:120px;border-radius:50%;background:#0c1530aa;border:1px solid #2c3b66;touch-action:none}
  .stick .knob{position:absolute;left:50%;top:50%;width:56px;height:56px;margin:-28px 0 0 -28px;border-radius:50%;background:#20325faa;border:1px solid #3a4f86}
  .rightpad{position:absolute;right:18px;bottom:18px;display:flex;flex-direction:column;gap:10px}
</style>
</head>
<body>
<!-- p5.js（会場オフラインならローカルに差し替え） -->
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>

<div id="ui">
  <!-- トップバー -->
  <div class="topbar">
    <button class="b primary" id="btnMenu">メニュー</button>
    <span id="status" style="margin-left:auto;color:#c7d4ff"></span>
  </div>

  <!-- メニュー -->
  <div id="menu">
    <div class="card">
      <h1>宇宙ミニゲーム・コレクション</h1>
      <p>スマホでもOK。遊びたいゲームを選んでね。</p>
      <div class="grid" style="margin-top:8px">
        <button class="b" id="goBH">① ブラックホール脱出</button>
        <button class="b" id="goCON">② 星座つなぎ</button>
        <button class="b" id="goDOP">③ ドップラー当て</button>
        <button class="b" id="goLEN">④ 重力レンズ迷路</button>
      </div>
      <p class="foot">操作：左下スティック or 端末の傾き（iOSは下の許可が必要）</p>
      <button class="b" id="askMotion">加速度センサーを許可（iOS）</button>
    </div>
  </div>

  <!-- 画面スティック／右操作 -->
  <div class="stick" id="stick"><div class="knob"></div></div>
  <div class="rightpad hidden" id="rightpad">
    <button class="b good" style="font-size:16px;padding:14px 18px" id="btnBlue">近づく（青方）</button>
    <button class="b bad"  style="font-size:16px;padding:14px 18px" id="btnRed">遠ざかる（赤方）</button>
  </div>
</div>

<script>
/* ========= 共通：状態・入力 ========= */
let W=window.innerWidth, H=window.innerHeight;
let current='menu';
const statusEl=document.getElementById('status');
const menuEl=document.getElementById('menu');
const rightpadEl=document.getElementById('rightpad');

document.getElementById('btnMenu').onclick=()=>setState('menu');
document.getElementById('goBH').onclick = ()=>startBH();
document.getElementById('goCON').onclick= ()=>startCON();
document.getElementById('goDOP').onclick= ()=>startDOP();
document.getElementById('goLEN').onclick= ()=>startLEN();

document.getElementById('askMotion').onclick= async ()=>{
  try{
    if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      const r=await DeviceMotionEvent.requestPermission();
      alert(r==='granted'?'有効化しました。傾きで操作できます。':'許可されませんでした。スティックで操作してください。');
    } else {
      alert('この端末は明示許可不要、または未対応です。');
    }
  }catch(e){ alert('許可リクエストでエラー: '+e); }
};

function setState(s){
  current=s;
  // 表示/非表示をクラスで一元管理
  menuEl.classList.toggle('hidden', s!=='menu');
  rightpadEl.classList.toggle('hidden', s!=='dop');
  // UIのクリック可否も明示
  menuEl.style.pointerEvents  = (s==='menu') ? 'auto' : 'none';
  rightpadEl.style.pointerEvents = (s==='dop') ? 'auto' : 'none';
}

/* ========= 仮想スティック ========= */
let joy={active:false, base:null, knob:null, dx:0, dy:0};
(function initStick(){
  const el=document.getElementById('stick');
  joy.base=el; joy.knob=el.querySelector('.knob');
  const start=(e)=>{ joy.active=true; move(e); e.preventDefault(); };
  const move=(e)=>{
    if(!joy.active) return;
    const r=joy.base.getBoundingClientRect();
    const cx=r.left+r.width/2, cy=r.top+r.height/2;
    const pt=getPoint(e);
    let dx=pt.x-cx, dy=pt.y-cy;
    const max=r.width*0.45;
    const mag=Math.hypot(dx,dy);
    if(mag>max){ dx*=max/mag; dy*=max/mag; }
    joy.knob.style.transform=`translate(${dx}px,${dy}px)`;
    joy.dx = dx/max; joy.dy = dy/max;
  };
  const end=()=>{ joy.active=false; joy.dx=0; joy.dy=0; joy.knob.style.transform='translate(0,0)'; };
  el.addEventListener('pointerdown',start);
  window.addEventListener('pointermove',move);
  window.addEventListener('pointerup',end);
  window.addEventListener('pointercancel',end);
})();
function getPoint(e){ if(e.touches && e.touches[0]) return {x:e.touches[0].clientX,y:e.touches[0].clientY}; return {x:e.clientX,y:e.clientY}; }

/* ========= 傾き入力 ========= */
let accel={ax:0, ay:0};
window.addEventListener('deviceorientation',(ev)=>{
  const gx=Math.sin((ev.gamma||0)*Math.PI/180);
  const gy=Math.sin((ev.beta||0)*Math.PI/180);
  accel.ax=gx; accel.ay=gy;
});

/* ========= p5 ベース ========= */
const TAU=Math.PI*2;
let bgStars=[];
function drawStarsBG(p){
  if(bgStars.length===0){
    for(let i=0;i<180;i++) bgStars.push({x:Math.random()*W,y:Math.random()*H,s:Math.random()*2+0.5,t:Math.random()*TAU});
  }
  p.noStroke();
  for(const s of bgStars){
    s.t+=0.02; const tw=(Math.sin(s.t)+1)*0.5*180+50;
    p.fill(200,220,255,tw); p.circle(s.x,s.y,s.s);
  }
}
let sketch=(p)=>{
  p.setup=()=>{
    p.createCanvas(W,H);
    setupBH(p); setupCON(p); setupDOP(p); setupLEN(p);
    setState('menu');
  };
  p.windowResized=()=>{ W=window.innerWidth; H=window.innerHeight; p.resizeCanvas(W,H); bgStars=[]; };
  p.draw=()=>{
    p.background(10,16,36);
    if(current==='menu'){ drawStarsBG(p); }
    else if(current==='bh'){ drawBH(p); }
    else if(current==='con'){ drawCON(p); }
    else if(current==='dop'){ drawDOP(p); }
    else if(current==='len'){ drawLEN(p); }
  };
};
new p5(sketch);

/* ========= ① ブラックホール脱出 ========= */
let bh;
function setupBH(p){
  const reset=()=>({
    ship:{x:W*0.75,y:H*0.5,vx:0,vy:-2,r:10},
    t:0, alive:true, score:0,
    R:Math.min(W,H)*0.1, G:1400
  });
  bh=reset();
  bh.reset=()=>Object.assign(bh,reset());
}
function startBH(){ setState('bh'); bh.reset(); }
function drawBH(p){
  p.push(); p.translate(W/2,H/2);
  for(let i=0;i<40;i++){ const r=bh.R+i*2; p.noFill(); p.stroke(40,60,120,120-i*3); p.circle(0,0,r*2); }
  p.noStroke(); p.fill(20); p.circle(0,0,bh.R*2); p.pop();

  const s=bh.ship;
  const ux=accel.ax*0.8 + joy.dx*1.2, uy=accel.ay*0.8 + joy.dy*1.2;
  s.vx+=ux*0.3; s.vy+=uy*0.3;

  const dx=W/2 - s.x, dy=H/2 - s.y;
  const r=Math.hypot(dx,dy), soft=60;
  const a=bh.G/((r*r)+soft*soft);
  s.vx+=a*dx; s.vy+=a*dy;

  const vmax=8, v=Math.hypot(s.vx,s.vy); if(v>vmax){ s.vx*=vmax/v; s.vy*=vmax/v; }
  s.x+=s.vx; s.y+=s.vy;

  if(s.x<0||s.x>W){ s.vx*=-0.7; s.x=Math.max(0,Math.min(W,s.x)); }
  if(s.y<0||s.y>H){ s.vy*=-0.7; s.y=Math.max(0,Math.min(H,s.y)); }
  if(r<bh.R){ bh.alive=false; }
  if(bh.alive) bh.t+=1;
  bh.score=(bh.t/60).toFixed(1);

  p.push(); p.translate(s.x,s.y); p.rotate(Math.atan2(s.vy,s.vx));
  p.fill(220); p.triangle(-12,-6,-12,6,12,0);
  p.fill(255,160); p.triangle(-12,-4,-12,4,-20,0);
  p.pop();

  statusEl.textContent = bh.alive?`生存 ${bh.score}s`:`吸い込まれた！ 生存 ${bh.score}s`;
  if(!bh.alive){ p.fill(255); p.textAlign(p.CENTER); p.textSize(20); p.text('ゲームオーバー\nメニューでやり直し', W/2, H*0.2); }
}

/* ========= ② 星座つなぎ（簡略オリオン） ========= */
let con;
function setupCON(p){
  function make(){
    const cx=W*0.5, cy=H*0.5, s=Math.min(W,H)*0.28;
    const pts=[
      {name:'Betelgeuse',x:-0.2,y:-0.4},
      {name:'Bellatrix', x: 0.2,y:-0.35},
      {name:'Mintaka',   x:-0.25,y:-0.05},
      {name:'Alnilam',   x: 0.00,y: 0.00},
      {name:'Alnitak',   x: 0.25,y: 0.05},
      {name:'Rigel',     x: 0.25,y: 0.40},
      {name:'Saiph',     x:-0.15,y: 0.38}
    ].map(p=>({name:p.name,x:cx+p.x*s,y:cy+p.y*s,r:10}));
    const order=[0,2,3,4,5,6,3,1,0];
    return {pts,order,cur:0,lines:[],done:false,_down:false};
  }
  con=make(); con.reset=()=>Object.assign(con,make());
}
function startCON(){ setState('con'); con.reset(); }
function drawCON(p){
  drawStarsBG(p);
  p.noStroke();
  for(const s of con.pts){ p.fill(220); p.circle(s.x,s.y,s.r); }
  p.stroke(150,190,255); p.strokeWeight(2);
  for(const L of con.lines) p.line(L.x1,L.y1,L.x2,L.y2);

  const idx=con.order[con.cur]; const target=con.pts[idx];
  p.noFill(); p.stroke(255,220,120,180); p.circle(target.x,target.y,24);

  if(p.mouseIsPressed){
    if(!con._down){
      con._down=true;
      const hit=hitStar(p.mouseX,p.mouseY,con.pts);
      if(hit===idx){
        if(con.cur>0){
          const prev=con.pts[con.order[con.cur-1]];
          con.lines.push({x1:prev.x,y1:prev.y,x2:target.x,y2:target.y});
        }
        con.cur++; if(con.cur>=con.order.length) con.done=true;
      }
    }
  } else con._down=false;

  if(con.done){
    p.noStroke();
    for(let i=0;i<40;i++){ p.fill(255,240,120,120-i*3); p.circle(W/2,H/2, i*8); }
    p.fill(255); p.textAlign(p.CENTER); p.textSize(20); p.text('星座完成！', W/2, H*0.15);
  }
  statusEl.textContent = con.done?'完成！':'点を順にタップして線で結ぼう';
}
function hitStar(x,y,pts){ for(let i=0;i<pts.length;i++){ const s=pts[i]; if((x-s.x)**2+(y-s.y)**2 <= (s.r*1.1)**2) return i; } return -1; }

/* ========= ③ ドップラー当て ========= */
let dop;
function setupDOP(p){
  const reset=()=>({t:0,score:0,life:3,cur:{x:W*0.1,y:H*0.5,v:2,vr:300,color:[200,200,255],answer:null}});
  dop=reset(); dop.reset=()=>Object.assign(dop,reset());
  document.getElementById('btnBlue').onclick=()=>judgeDOP(-1);
  document.getElementById('btnRed').onclick =()=>judgeDOP(+1);
}
function startDOP(){ setState('dop'); dop.reset(); spawnDOP(); }
function spawnDOP(){
  const vr=(Math.random()<0.5?-1:1)*(50+Math.random()*600);
  const hue=vr>0?[255,120,120]:[120,160,255];
  dop.cur={x:W*0.08,y:Math.random()*H*0.6+H*0.2,v:2.3+Math.random()*1.7,vr,color:hue,answer:(vr<0?-1:+1)};
}
function drawDOP(p){
  rightpadEl.classList.remove('hidden'); rightpadEl.style.pointerEvents='auto';
  for(let i=0;i<W;i+=6){ const r=80+80*Math.sin((i+performance.now()*0.0008)); p.stroke(r,r*0.9,180,60); p.line(i,0,i,H); }
  const c=dop.cur; c.x+=c.v;
  p.noStroke(); p.fill(c.color[0],c.color[1],c.color[2]); p.circle(c.x,c.y,28);
  p.fill(230); p.textSize(14); p.textAlign(p.LEFT); p.text('判定：近づく=青方 / 遠ざかる=赤方', 10, 24);
  if(c.x>W+20){ dop.life--; spawnDOP(); }
  statusEl.textContent=`スコア ${dop.score} / ライフ ${dop.life}`;
  if(dop.life<=0){ p.fill(255); p.textAlign(p.CENTER); p.textSize(22); p.text('ゲーム終了！ メニューでリトライ', W/2, H*0.5); }
}
function judgeDOP(guess){
  if(dop.life<=0) return;
  const correct=(guess===dop.cur.answer);
  if(correct) dop.score++; else dop.life--;
  spawnDOP();
}

/* ========= ④ 重力レンズ迷路 ========= */
let lenz;
function setupLEN(p){
  const reset=()=>({src:{x:W*0.12,y:H*0.5},goal:{x:W*0.88,y:H*0.5,r:18},
    mass:{x:W*0.5,y:H*0.5,M:24000,r:26,dragging:false}, solved:false});
  lenz=reset(); lenz.reset=()=>Object.assign(lenz,reset());

  window.addEventListener('pointerdown',(e)=>{
    if(current!=='len') return;
    const pt=getPoint(e);
    if((pt.x-lenz.mass.x)**2+(pt.y-lenz.mass.y)**2 < (lenz.mass.r+10)**2) lenz.mass.dragging=true;
  });
  window.addEventListener('pointermove',(e)=>{
    if(current!=='len'||!lenz.mass.dragging) return;
    const pt=getPoint(e); lenz.mass.x=pt.x; lenz.mass.y=pt.y;
  });
  window.addEventListener('pointerup',()=>{ if(current==='len') lenz.mass.dragging=false; });
}
function startLEN(){ setState('len'); lenz.reset(); }
function drawLEN(p){
  drawStarsBG(p);
  p.noStroke();
  p.fill(120,220,255,180); p.circle(lenz.goal.x,lenz.goal.y,lenz.goal.r*2);
  p.fill(255,230,120,200); p.circle(lenz.src.x,lenz.src.y,14);
  p.fill(120,160,255,180); p.circle(lenz.mass.x,lenz.mass.y,lenz.mass.r*2);

  const pts=[]; let x=lenz.src.x,y=lenz.src.y; let vx=3.0,vy=0.0;
  for(let i=0;i<1300;i++){
    const dx=lenz.mass.x-x, dy=lenz.mass.y-y;
    const rr=Math.max(40,Math.hypot(dx,dy));
    const a=lenz.mass.M/(rr*rr*2600);
    vx+=a*dx; vy+=a*dy;
    const v=Math.hypot(vx,vy); vx/=v; vy/=v; vx*=3.0; vy*=3.0;
    x+=vx; y+=vy; pts.push([x,y]);
    if((x-lenz.goal.x)**2+(y-lenz.goal.y)**2 < (lenz.goal.r)**2){ lenz.solved=true; break; }
    if(x<0||x>W||y<0||y>H) break;
  }
  p.noFill(); p.stroke(255,240,180,200); p.strokeWeight(2); p.beginShape(); for(const q of pts) p.vertex(q[0],q[1]); p.endShape();
  p.noStroke(); p.fill(255); p.textSize(16); p.textAlign(p.LEFT); p.text('青丸（銀河）をドラッグして光をゴールへ', 10, 22);
  statusEl.textContent = lenz.solved?'クリア！':'ドラッグで配置を調整';
}
</script>
</body>
</html>
